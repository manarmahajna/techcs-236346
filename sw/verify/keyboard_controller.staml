/* Keyboard Controller Implementation
 * Uses GPIO for keyboard input with polling
 * Based on 05-loop-verif.pdf
 */

/* Wait for keyboard input
 * Returns the key code when a key is pressed
 * 
 * Algorithm:
 * 1. Read current sequence number from GPIO_IN_HI
 * 2. Poll until sequence number changes
 * 3. Return key code from GPIO_IN_LO
 */
wait(0) = 
    mem_peek 0xc001;    // Read sequence number
    wait_aux

wait_aux(1) =
    if (mem_peek 0xc001) - $0    // Has sequence changed?
    then mem_peek 0xc000         // Yes: return key code
    else wait_aux $0             // No: keep polling (tail call!)

/* Alternative implementation with explicit recursion */
wait_recursive(0) =
    let seq = mem_peek 0xc001 in
    let aux(seq) =
        if (mem_peek 0xc001) == seq
        then aux(seq)              // Tail recursive!
        else mem_peek 0xc000
    in aux(seq)

/* Get key with timeout
 * Returns key code or -1 if timeout
 */
wait_with_timeout(1) =
    let seq = mem_peek 0xc001 in
    wait_timeout_aux seq $0

wait_timeout_aux(2) =
    if $1 < 1 then -1             // Timeout
    else if (mem_peek 0xc001) - $0 
         then mem_peek 0xc000     // Key pressed
         else wait_timeout_aux $0 ($1 - 1)  // Tail call

/* Check if key is available (non-blocking) */
key_available(0) =
    let seq = mem_peek 0xc001 in
    let new_seq = mem_peek 0xc001 in
    if seq == new_seq then 0 else 1

/* Read key if available, else return default */
try_read_key(1) =
    if key_available() 
    then mem_peek 0xc000
    else $0    // Return default value

/* Key code constants */
KEY_UP = 0x01
KEY_DOWN = 0x02
KEY_LEFT = 0x04
KEY_RIGHT = 0x08
KEY_SPACE = 0x20
KEY_ENTER = 0x0D
KEY_ESC = 0x1B

/* Process key input for Snake game */
process_key(2) =
    let key = wait() in
    if key == KEY_UP then $0(0)
    else if key == KEY_DOWN then $0(1)
    else if key == KEY_LEFT then $0(2)
    else if key == KEY_RIGHT then $0(3)
    else $1(key)    // Unknown key callback
